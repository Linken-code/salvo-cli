use std::sync::Arc;
use std::time::Duration;

use tokio::signal;
use tracing::info;
use crate::routers::router;
use salvo::server::ServerHandle;
use salvo::catcher::Catcher;
use salvo::conn::rustls::{Keycert, RustlsConfig};
use salvo::prelude::*;
use dotenvy::dotenv;
use figment::Figment;
use figment::providers::{Env, Format, Toml};

use figment::Figment;

mod config;
mod db;
mod models;
mod utils;
{% if db_lib == "diesel" %}
mod schema;
{% endif %}
mod hoops;
mod routers;
mod env_vars;

mod error;
pub use error::AppError;

pub type AppResult<T> = Result<T, AppError>;
pub type JsonResult<T> = Result<Json<T>, AppError>;
pub type EmptyResult = Result<Json<Empty>, AppError>;

pub fn json_ok<T>(data: T) -> JsonResult<T> {
    Ok(Json(data))
}
#[derive(Serialize, ToSchema, Clone, Copy, Debug)]
pub struct Empty {}
pub fn empty_ok() -> JsonResult<Empty> {
    Ok(Json(Empty {}))
}

use config::ServerConfig;
pub fn config() -> &'static ServerConfig {
    &*crate::config::CONFIG
}

#[tokio::main]
async fn main() {
    if let Err(e) = dotenv() {
        println!("dotenv error: {:?}", e);
    }

    let raw_config = Figment::new()
        .merge(Toml::file(Env::var("APP_CONFIG").as_deref().unwrap_or("config.toml")))
        .merge(Env::prefixed("APP_").global());

    let config = match raw_config.extract::<ServerConfig>() {
        Ok(s) => s,
        Err(e) => {
            eprintln!("It looks like your config is invalid. The following error occurred: {e}");
            std::process::exit(1);
        }
    };
    crate::config::CONFIG.set(config).expect("config should be set");
    let config = crate::config();

    {% if db_lib == "diesel" %}
    let thread_pool = Arc::new(ScheduledThreadPool::new(conf.db.helper_threads));

    let db_primary = {
        let db_connection_config = ConnectionConfig {
            statement_timeout: config.db.statement_timeout,
        };

        let db_config = r2d2::Pool::builder()
            .max_size(conf.db.pool_size)
            .min_idle(conf.db.min_idle)
            .connection_timeout(Duration::from_millis(config.db.connection_timeout))
            .connection_customizer(Box::new(db_connection_config))
            .thread_pool(thread_pool.clone());

        DieselPool::new(&config.db.url, &config.db, db_config).unwrap()
    };
    crate::db::DIESEL_POOL
        .set(db_primary)
        .expect("diesel pool should be set");
    {% endif %}

    crate::db::migrate();

    let _guard = config.log.guard();
    tracing::info!("log level: {}", &config.log.filter_level);

    let service = Service::new(routers::root())
        .catcher(Catcher::default().hoop(handle_404))
        .hoop(cors_hoop());
    println!("ðŸ”„ {{listen_on}} {}", &config.listen_addr);
    if config.ssl {
        println!(
            "ðŸ“– {{open_api_page}}: https://{}/scalar",
            config.listen_addr.replace("0.0.0.0", "127.0.0.1")
        );
        println!(
            "ðŸ”‘ Login Page: https://{}/login",
            config.listen_addr.replace("0.0.0.0", "127.0.0.1")
        );
        let config = RustlsConfig::new(
            Keycert::new()
                .cert(CERT_KEY.cert.clone())
                .key(CERT_KEY.key.clone()),
        );
        let acceptor = TcpListener::new(&config.listen_addr)
            .rustls(config)
            .bind()
            .await;
        let server = Server::new(acceptor);
        tokio::spawn(shutdown_signal(server.handle()));
        server.serve(service).await;
    } else {
        println!(
            "ðŸ“– {{open_api_page}}: http://{}/scalar",
            config.listen_addr.replace("0.0.0.0", "127.0.0.1")
        );
        println!(
            "ðŸ”‘ Login Page: http://{}/login",
            config().server.listen_addr.replace("0.0.0.0", "127.0.0.1")
        );
        let acceptor = TcpListener::new(&config.listen_addr).bind().await;
        let server = Server::new(acceptor);
        tokio::spawn(shutdown_signal(server.handle()));
        server.serve(service).await;
    }
}

async fn shutdown_signal(handle: ServerHandle) {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => info!("ctrl_c signal received"),
        _ = terminate => info!("terminate signal received"),
    }
    handle.stop_graceful(std::time::Duration::from_secs(60));
}

#[cfg(test)]
mod tests {
    use salvo::prelude::*;
    use salvo::test::{ResponseExt, TestClient};

    use crate::config;

    #[tokio::test]
    async fn test_hello_world() {
        let service = Service::new(super::router());

        let content = TestClient::get(format!(
            "http://{}",
            &config().address.replace("0.0.0.0", "127.0.0.1")
        ))
        .send(&service)
        .await
        .take_string()
        .await
        .unwrap();
        assert_eq!(content, "Hello World from salvo");
    }
}

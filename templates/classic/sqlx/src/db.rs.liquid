use crate::config::CFG;
{%- if db_lib == "sqlx" %}
{%- if db_type == "mysql" %}
use sqlx::MySqlPool;
{%- endif %}
{%- if db_type == "postgres" %}
use sqlx::PgPool;
{%- endif %}
{%- if db_type == "sqlite" %}
use sqlx::SqlitePool;
{%- endif %}
{%- endif %}
{%- if db_lib == "seaorm" %}
use std::time::Duration;
use seaorm::{entity::prelude::DatabaseConnection, ConnectOptions, Database};
{%- endif %}
use tokio::sync::OnceCell;
{%- if db_lib == "diesel" %}
use diesel::prelude::*;
{%- if db_type == "sqlite" %}
pub fn establish_connection() -> SqliteConnection {
    let conn = SqliteConnection::establish(&config().db.database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", &config().db.database_url));
    conn
}
{%- endif %}
{%- if db_type == "mysql" %}
pub fn establish_connection() -> MysqlConnection {
    MysqlConnection::establish(&config().db.database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", &config().db.database_url))
}
{%- endif %}
{%- if db_type == "postgres" %}
pub fn establish_connection() -> PgConnection {
    PgConnection::establish(&config().db.database_url)
        .unwrap_or_else(|_| panic!("Error connecting to {}", &config().db.database_url))
}
{%- endif %}
{%- endif %}
{%- if db_lib == "sqlx" %}
{%- if db_type == "sqlite" %}
pub static DB: OnceCell<SqlitePool> = OnceCell::const_new();
{%- endif %}
{%- if db_type == "postgres" %}
pub static DB: OnceCell<PgPool> = OnceCell::const_new();
{%- endif %}
{%- if db_type == "mysql" %}
pub static DB: OnceCell<MySqlPool> = OnceCell::const_new();
{%- endif %}
pub async fn init_db_conn() {
    DB.get_or_init(|| async {
        {%- if db_lib == "sqlx" %}
        {%- if db_type == "sqlite" %}
        SqlitePool::connect(&config().db.database_url)
            .await
            .expect("{{database_connection_failed}}")
        {%- endif %}
        {%- if db_type == "postgres" %}
        PgPool::connect(&config().db.database_url)
            .await
            .expect("{{database_connection_failed}}")
        {%- endif %}
        {%- if db_type == "mysql" %}
        MySqlPool::connect(&config().db.database_url)
        .await
        .expect("{{database_connection_failed}}")
        {%- endif %}
        {%- endif %}
    })
    .await;
}
{%- endif %}
{%- if db_lib == "seaorm" %}
pub static DB: OnceCell<DatabaseConnection> = OnceCell::const_new();

pub async fn init_db_conn() {
	DB.get_or_init(|| async {
		let mut opt = ConnectOptions::new(config().db.database_url.to_owned());
		opt.max_connections(1000)
			.min_connections(5)
			.connect_timeout(Duration::from_secs(8))
			.idle_timeout(Duration::from_secs(8))
			.sqlx_logging(false);

		Database::connect(opt).await.expect("数据库打开失败")
	})
	.await;
}
{%- endif %}
{%- if db_lib == "rbatis" %}
use tokio::sync::OnceCell;
use rbatis::rbatis::RBatis;
pub static DB: OnceCell<RBatis> = OnceCell::const_new();

pub async fn init_db_conn() {
    DB.get_or_init(|| async {
        let rb = RBatis::new();

        {%- if db_type == "postgres" %}
        // PostgreSQL
        rb.init(rbdc_pg::driver::PgDriver {}, &config().db.database_url).unwrap();
        {%- endif %}
        {%- if db_type == "mysql" %}
        // MySQL
        rb.init(rbdc_mysql::driver::MysqlDriver {}, &config().db.database_url).unwrap();
        {%- endif %}
        {%- if db_type == "sqlite" %}
        // SQLite
        rb.init(rbdc_sqlite::driver::SqliteDriver {}, &config().db.database_url).unwrap();
        {%- endif %}

        let sql_file = match rb.driver_type().unwrap() {
            "sqlite" => "./data/table_sqlite.sql",
            "postgres" => "./data/table_postgres.sql",
            "mysql" => "./data/table_mysql.sql",
            "mssql" => "./data/table_mssql.sql",
            _ => { "" }
        };
        if sql_file != "" {
            let sql = std::fs::read_to_string(sql_file).unwrap();
            let _ = rb.exec(&sql, vec![]).await;
        }
        return rb;    
    })
    .await;
}
{%- endif %}
{%- if db_type == "mongodb" %}
use crate::entities::user::User;
use mongodb::{bson::doc, options::IndexOptions, Client, IndexModel};
use once_cell::sync::OnceCell;
pub const DB_NAME: &str = "myApp";
pub const COLL_NAME: &str = "users";
pub static MONGODB_CLIENT: OnceCell<Client> = OnceCell::new();
pub async fn init_db_conn() {
        let mongodb_uri = &config().db.database_url;
    let client = Client::with_uri_str(mongodb_uri)
        .await
        .expect("failed to connect");
    let options = IndexOptions::builder().unique(true).build();
    let model = IndexModel::builder()
        .keys(doc! { "username": 1 })
        .options(options)
        .build();
    client
        .database(DB_NAME)
        .collection::<User>(COLL_NAME)
        .create_index(model, None)
        .await
        .expect("creating an index should succeed");
    MONGODB_CLIENT.get_or_init(|| client);
}
{%- endif %}

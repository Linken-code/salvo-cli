use std::sync::OnceLock;

use rbatis::RBatis;

use crate::config::DbConfig;

pub static RBATIS_ENGINE: OnceLock<RBatis> = OnceLock::new();

pub async fn init(config: &DbConfig) {
    let rb = RBatis::new();
    {%- if db_type == "sqlite" %}
    rb.init(rbdc_sqlite::driver::SqliteDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/init.sql";
    {%- elsif db_type == "postgres" %}
    rb.init(rbdc_pg::driver::PgDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/init.sql";
    {%- elsif db_type == "mysql" %}
    rb.init(rbdc_mysql::driver::MysqlDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/init.sql";
    {%- endif %}

    if sql_file != "" {
        let sql = std::fs::read_to_string(sql_file).unwrap();
        let _ = rb.exec(&sql, vec![]).await;
    }
    RBATIS_ENGINE.set(rb).expect("rbatis should be set");

    migrate().await;
}

async fn migrate() {
    let rb = engine();

    // Create table if not exists and try to insert initial user with OR IGNORE
    rb.exec("CREATE TABLE IF NOT EXISTS users (
        id VARCHAR(255) PRIMARY KEY NOT NULL,
        username VARCHAR(255) NOT NULL UNIQUE,
        password VARCHAR(511) NOT NULL
    );
    INSERT OR IGNORE INTO users (id, username, password) 
    VALUES ('cdd0e080-5bb1-4442-b6f7-2ba60dbd0555', 'zhangsan', '$argon2id$v=19$m=19456,t=2,p=1$rcosL5pOPdA2c7i4ZuLA4Q$s0JGh78UzMmu1qZMpVUA3b8kWYLXcZhw7uBfwhYDJ4A');", vec![])
        .await.expect("Database migration failed");
}

pub fn engine() -> &'static RBatis {
    RBATIS_ENGINE.get().expect("rbatis should be initialized")
}
use std::sync::OnceLock;

use rbatis::RBatis;

use crate::config::DbConfig;

pub static DIESEL_POOL: OnceLock<DieselPool> = OnceLock::new();

pubm async fn init(config: &DbConfig) {
    let rb = RBatis::new();
    {%- if db_type == "sqlite" %}
    rb.init(rbdc_sqlite::driver::SqliteDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/table_sqlite.sql";
    {%- elsif db_type == "postgres" %}
    rb.init(rbdc_sqlite::driver::PostgresDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/table_postgres.sql";
    {%- elsif db_type == "mysql" %}
    rb.init(rbdc_sqlite::driver::SqliteDriver {}, &config.url)
        .unwrap();
    let sql_file = "./data/table_mysql.sql";
    {%- else %}

    if sql_file != "" {
        let sql = std::fs::read_to_string(sql_file).unwrap();
        let _ = rb.exec(&sql, vec![]).await;
    }
    RBATIS_POOL.set(rb).expect("rbatis should be set")
}

pub fn connect() -> &'static RBatis {
    RBATIS_POOL.get().expect("rbatis should be initialized")
}